{"title":"Osagai","logo":"üÄÑÔ∏è","githubRepo":"HenriqueLimas/osagai","googleAnalytics":"UA-131796214-1","index":{"title":"Home","description":"Create WebComponents with no class, just functions","content":" Simple component Osagai export a define() function to create your WebComponent. Your component is a function that returns a template with the view definition Adding event listeners In addition, in you component function it will be injected some useful methods like query that you could query inside the component tree and add event listeners with the on method from osagai/events. An application Besides query, Osagai will also inject an update function that you can use for changing the data (or state) being used in the template function. This will check what it needs to be changed in the DOM and apply the re-render A real application This a \"real\" example of the Hacker News implemented with Osagai as a PWA. You can se the code on Github, or try it live here. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/docs/search.html"},"getting-started":{"description":"Getting started with a Osagai.","icon":"arrow-right-rod","layout":"guide","title":"Getting Started","weight":1,"content":" Install Using package managers You can get it on npm. npm install osagai Or with yarn yarn add osagai Import from a CDN You can also import directly from unpkg import { define } from \"https://unpkg.com/osagai/osagai.mjs\"; CDN links Osagai are available over a CDN. Define a Web component Osagai comes with a function called define that defines a new custom element that you can use in your application. define receives the name of the custom element (it must contain a hyphen) and the Osagai component. The Osagai component is a function that returns a Template with a string representing the layout of the web component. import { define } from 'osagai' function MyComponent() { return () = Hi üëã! } define('waving-hand', MyComponent) Now, you just need to use your new custom element in your application. Modules Osagai is separated by different modules, in a way that you can import only what you need for your custom element. osagai This is the main module where you can find the function for defining your custom element. import { define } from 'osagai' dom This is the module with useful methods like update for efficiently update the DOM tree of your custom element import { update } from 'osagai/dom' events This is the module with useful methods like on for adding event listeners to components import { on } from 'osagai/events' lifecycles This is the module for the custom elements lifecyles like connectedCallback and disconnectedCallback import { onConnected, onDisconnected } from 'osagai/lifecycles' ","srcFilePath":"src/pages/docs/getting-started/index.md","id":"getting-started","location":"/docs/getting-started/","url":"/docs/getting-started/"},"api-reference":{"description":"API reference","icon":"code-file","layout":"guide","title":"API reference","weight":2,"content":" Osagai is separated in different modules that you can import only what you need for implementing your custom element. These are the modules with a short description: osagai Main module with a function for defining your custom elements. dom Module with functions for manipulating the DOM tree of the custom element. events Module with functions for adding event listeners. lifecycles Module with functions for listening the lifecyles of the custom element. ","srcFilePath":"src/pages/docs/api-reference/index.md","id":"api-reference","location":"/docs/api-reference/","url":"/docs/api-reference/","children":{"dom":{"title":"dom","description":"Osagai dom","layout":"guide","weight":2,"content":" Overview The osagai/dom module has functions responsible for manipulating the DOM tree of the custom element. Use this module if your custom element will need to update the data and efficiently update the DOM. update Update DOM elements Usually, our components needs to be updated reflecting the data passed in the Template function into the DOM. This could not be so performant if we always use innerHTML for reflecting the template defined. For that reason, osagai use a library called morphdom that change only the elements in the DOM that differentiate from the previous state. Note: If you use a custom renderer in the define function, the update function will use that custom renderer instead of mophdom. Reference update update(element, dataChanger) = Promise(newData) Updates the data of the Component, scheduling a new change in the DOM using the renderer (default to morphdom) and return a promise with the new data returned by the dataChanger. Parameters element Instance of the osagai element dataChanger Function that receive as parameter the data that needs to be changed and needs to return the new data. This could also be a promise that will be resolved by the update function. Example update(element, (data = {}) = { data.changed = true return data }) Async function update(element, async (data = {}) = { const items = await api.getItems() data.items = items return data }) attachShadow attachShadow(element, [shadowRootInit]) = ShadowRoot Adds a shadow DOM tree to the specified element and returns the attached ShadowRoot Parameters element Instance of the osagai element shadowRootInit An object that contain the following field: mode: A string specyfing the encapsulation mode for the shadow DOM tree. open [default]: Elements from the shadow dom are accessible with the property element.shadowRoot close: Elements from the shadow dom are not accessible Example const openShadowRoot = attachShadow(element) // element.shadowRoot === openShadowRoot const closedShadowRoot = attachShadow(element, { mode: 'close' }) // element.shadowRoot === null ","srcFilePath":"src/pages/docs/api-reference/dom/index.md","id":"dom","location":"/docs/api-reference/dom/","url":"/docs/api-reference/dom/"},"events":{"title":"events","description":"Osagai events","layout":"guide","weight":3,"content":" Overview The osagai/events module has functions for adding event listeners in your custom element DOM tree. Use this module if you need to listen to events. on Reference on on(eventType, element, callback) = Promise Add an event listener to the element and return a promise when this is done. Parameters eventType A case-sensitive string representing the event type to listen for element Instance of the element to add the event listener. It could be also a promise that resolve with the element (ex. query and queryAll functions from the component function) callback A function that runs when the event type occurs. It could also be an object that implements the EventListener interface. Example on('click', query('button'), (event) = { api.makeSomeMagic() }) ","srcFilePath":"src/pages/docs/api-reference/events/index.md","id":"events","location":"/docs/api-reference/events/","url":"/docs/api-reference/events/"},"lifecycles":{"title":"lifecycles","description":"Osagai lifecycles","layout":"guide","weight":3,"content":" Overview The osagai/lifecycles module has functions for listening to lifecyles of the custom element. Use this module if you need to define different callbacks which are fired at different points in the element's lifecycle. onConnected onDisconnected onAttributeChanged Lifecycles Connected A custom element is consider as connected when the element is appended into a document. This will also happen when the element is moved. Disconnected The custom element is disconnected when it is removed from the document. It could be useful for any necessary cleanup like subscriptions or cancelling network requests. Attribute changed This is invoked when an attribute from the observedAttributes list is added, changed or removed. This could be useful to make network request for updating the data. onAttributeChanged(element, ({ name, current }) = { if (name === 'userID') { update(element, async () = { return await api.getUser(current) }) } }) Reference onConnected onConnected(element, callback) Add a callback to be performed when the element is connected in the document. Parameters element Instance of the osagai element callback Function that will be perfomed when the element is connected. onDisconnected onDisconnected(element, callback) Add a callback to be performed when the element is disconnected from the document. Parameters element Instance of the osagai element callback Function that will be perfomed when the element is disconnected. onAttributeChanged onAttributeChanged(element, callback) Add a callback to be performed when one of the attribute from the observedAttributes list is added, changed or removed. Parameters element Instance of the osagai element callback Function that will be runned with an object with the information of the attribute changed: name: string that represent the name of the attribute that changed current: string with the new value old: string with the old value ","srcFilePath":"src/pages/docs/api-reference/lifecycles/index.md","id":"lifecycles","location":"/docs/api-reference/lifecycles/","url":"/docs/api-reference/lifecycles/"},"osagai":{"title":"osagai","description":"Osagai Top-Level API","layout":"guide","weight":1,"content":" Overview Define custom elements Osagai let you define your custom elements in a functional way, making than reusable and think about the separation of the component logic from the view. Custom elements can be defined using the define function, passing the name of the component with the Component function Component function Osagai Components are functions that will define your custom element. They need to return a Template function and can be used to add the logic of your custom element. Like adding event listeners, making api calls or initialize variables. Osagai will pass useful arguments to the Component like the element reference and methods like query and queryAll that you can use to query elements in the element DOM tree. Both methods return a promise resolving the value as the element that match the query. function Component({element, query, queryAll}) { /* ‚ú® Some magic here ‚ú® */ return () = Hello } Template function The template function is what will define the layout of your custom element and it will be executed during the connectedCallback lifecycle. The interface of the Template function is simple, it needs to return a string that will define the layout of the custom element: function Template() { return 'Hello' } If your components doesn't need a layout (Renderless component), you do not need to return a string, just execute your logic inside this function. function RenderlessTemplate() { window.addEventListener('resize', runSomething) } Osagai will pass as argument of the Template function the data needed for your layout. This is usually changed with the update function of the osagai/dom module. const initialData = {name: 'world'} function Template(data = initialData) { return Hello ${data.name} } Custom renderer Osagai consider the template of the custom element as string. Initialization and updates of the element are all based of strings, it uses innerHTML for the initialization and morphdom for the updates. But if you want to have a custom initialization and update, you can use the renderer option on the definition of the custom element. This is a function that receives the element and the template result with the current data. For example, you could use lit-html for manipulating the DOM in this way: import { define } from 'osagai' import { render, html } from 'lit-html'; function renderer(element, template) { render(template, element); } function LitComponent() { return () = htmlHello; } define('lit-component', LitComponent, { renderer }); Reference define define(name, Component[, options]) Defines a new custom element. Parameters name Name for the new custom element. Note that custom element names must contain a hyphen (ex. hello-world) Component Component is the function that will return a Template function that defines the layout of your custom element. Here you can run the logic of the component, like making api calls or add event listeners of the component elements Component class properties observedAttributes: array of strings with the attributes to observe and run attributeChangedCallback function HelloWorld() { /.../ } HelloWorld.observedAttributes = [\"name\"] define('hello-world', HelloWorld) options Optional BaseElement: element constructor that the component will extend. (Default HTMLElement) renderer: Custom renderer function to use during the render process. The function has two arguments element and template. Where element is the element reference and template is the result of the Template function with the current data. observedAttributes [DEPRECATED]: use Component.observedAttributes instead ...customElementOptions: All the other are options defined by the custom element spec (MDN link). ","srcFilePath":"src/pages/docs/api-reference/osagai/index.md","id":"osagai","location":"/docs/api-reference/osagai/","url":"/docs/api-reference/osagai/"}},"childIds":["osagai","dom","events","lifecycles"]}},"childIds":["getting-started","api-reference","search"]}},"childIds":["docs"]}}